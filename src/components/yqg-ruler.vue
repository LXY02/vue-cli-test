<!-- @author xinyiliang -->
<!-- @email xinyiliang@yangqianguan.com -->
<!-- @date 2020-09-09 10:50:23.314 -->
<!-- @desc generated by yqg-cli@1.0.0 -->

<template>
    <div class="yqg-ruler">
        <!--刻度表-->
        <div ref="scrollrule" class="ruler-content-wrapper">
            <!--正常刻度表-->
            <div class="ruler-content" :style="{width: `${rulerContentWidth}px`}">
                <div
                        v-for="(item, index) in counter"
                        :key="item"
                        class="choose-item"
                        :style="{width: `${gridWidth}px`}"
                >
                    <span class="number-item" :class="{'number-part': index % gridNumber == 0}" />
                    <span v-if="index % gridNumber == 0" class="number-text">
                        {{ index + minNum }}
                    </span>
                </div>
            </div>
        </div>

        <!--刻度表的针-->
        <div class="yqg-scroll-item-pointer" />
    </div>
</template>

<script>

    import BScroll from '@better-scroll/core';

    export default {
        name: 'YqgRuler',

        model: {
            prop: 'value',
            event: 'change'
        },

        props: {
            // 初始值
            value: {
                type: Number,
                default: 0
            },

            // 最大刻度
            maxNum: {
                type: Number,
                default: 100
            },

            // 最小刻度
            minNum: {
                type: Number,
                default: 0
            },

            // 间隔多少个小格显示数字
            gridNumber: {
                type: Number,
                default: 5
            },

            // 每一小格子的宽度
            gridWidth: {
                type: Number,
                default: 12
            }
        },

        data() {
            return {
                leftAndRightPadding: null
            };
        },

        computed: {
            counter() {
                return this.maxNum - this.minNum + 1;
            },

            halfGridWidth() {
                return this.gridWidth / 2;
            },

            rulerContentWidth() {
                return (this.counter - 1) * this.gridWidth + this.leftAndRightPadding;
            }
        },

        mounted() {
            this.init();
        },

        methods: {
            init() {
                this.leftAndRightPadding = this.$refs.scrollrule.getBoundingClientRect().width;

                this.$nextTick(() => {
                    // 上面padding拿到，rulerContentWidth设置完，dom更新后再初始化scrollRuler
                    // 不然滚动长度有问题会导致后面一部分长度无法滚动
                    this.scrollRuler = new BScroll(this.$refs.scrollrule, {
                        probeType: 3, // 实时监听滚动的位置并返回
                        scrollX: true
                    });

                    this.initScrollPosition();
                    this.initScrollEvent();
                });
            },

            initScrollPosition() {
                const startPosition = -(this.value - this.minNum) * this.gridWidth;
                this.scrollRuler.scrollTo(startPosition, 0, 0);
            },

            initScrollEvent() {
                this.scrollRuler.on('scrollEnd', pos => {
                    // 计算距离下一个刻度的差值
                    const posX = Math.abs(pos.x);
                    const remainder = posX % this.gridWidth;
                    let endNum = Math.floor(posX / this.gridWidth) + this.minNum; // 滚动停止所在的值

                    if (remainder) {
                        // 差值不为0
                        // 进行差值比较, 左右最近的刻度进行吸附
                        if (remainder < this.halfGridWidth) {
                            this.scrollRuler.scrollTo(-(posX - remainder), 0, 0);
                        } else {
                            endNum += 1;
                            this.scrollRuler.scrollTo(-(posX + (this.gridWidth - remainder)), 0, 0);
                        }
                    }

                    this.$emit('change', endNum);
                });
            }
        }
    };
</script>

<style lang="stylus" rel="stylesheet/scss" scoped>

    .yqg-ruler {
        position: relative;

        .ruler-content-wrapper {
            width: 100%;
            overflow: hidden;
            height: 58px;

            .ruler-content {
                box-sizing: border-box;
                display: flex;
                flex-wrap: nowrap;
                padding: 14px 50% 0;
                height: 58px;

                .choose-item {
                    display: flex;
                    flex-direction: column;
                    flex-shrink: 0;

                    .number-item {
                        margin-top: 8px;
                        width: 100%;
                        height: 6px;
                        border-left: 1px solid #e2e5e7;
                        border-bottom: 1px solid #f5f5f5;

                        &.number-part {
                            margin-top: 0;
                            height: 14px;
                        }
                    }

                    .number-text {
                        margin: 5px 0 0 -12px;
                        line-height: 1;
                        font-size: 12px;
                        text-align: center;
                    }

                    &:last-child .number-item {
                        border-bottom: none;
                    }
                }
            }
        }

        .yqg-scroll-item-pointer {
            position: absolute;
            top: 0;
            left: 50%;
            width: 3px;
            height: 28px;
            transform: translateX(-50%);
            border-top-left-radius: 2px;
            border-top-right-radius: 2px;
            background-color: #8c7fee;
        }
    }

</style>
